from copy import deepcopy
from datetime import datetime
import hashlib
from json import dumps
import sys
from urllib2 import unquote
from urlparse import parse_qs

from flask import (render_template, flash, redirect, session, url_for, request, 
                   g, jsonify, abort)
from flask_jwt import jwt_required
from flask.ext.jwt import current_user
from flask.ext.login import login_user, logout_user, login_required
from flask.ext.cors import cross_origin
from wtforms.ext.sqlalchemy.orm import model_form
from wtforms import (BooleanField, DateField, DateTimeField, SelectField,  
                     StringField, TextAreaField)
from wtforms.widgets import Select
from wtforms_components.widgets import ReadOnlyWidgetProxy
from wtforms.ext.sqlalchemy.fields import QuerySelectMultipleField
#import wtforms_json
from werkzeug import datastructures, ImmutableMultiDict

from app import app, db, lm, jwt
import forms
from models import User
from widgets import ChoicesSelect
import alchemy_models as alch
from sqlalchemy.orm.collections import InstrumentedList

# authentication/login form methods. We use flask_jwt for authentication, and 
# send out a JSON web token that is stored in the client and sent back with
# every request. The authentication back end is LDAP. We send out LDAP groups
# the user is in for use is role-based authorization on the front end (what to
# show the user). We do check the directory again when handling each request,
# and do not depend on the roles indicated in the jwt.

@jwt.authentication_handler
def authenticate(username, password):
    user = User(id=username, passwd=password)
    if user.active is not False:
        return user

@jwt.user_handler
def load_user(payload):
    userid = payload["id"] or None
    return User(id=userid)

@jwt.payload_handler
def make_payload(user):
    return {
        'id': user.id,
        'name': user.name,
        'firstname': user.firstname,
        'lastname': user.lastname,
        'mail': user.mail,
        'roles': user.groups,
        'active': user.active
    }

@app.route('/login', methods=['GET', 'POST'])
def login():
    form = forms.LoginForm(request.form)
    if request.method == 'POST' and form.validate():
        
        user = User(uid=form.username.data, passwd=form.password.data)
        if user.active is not False:
            login_user(user)
            flash("Logged in successfully.")
            return redirect(url_for("index"))
        else:
            flash("Invalid credentials. Please try again.")
            return redirect(url_for("login"))
    return render_template("login.html", form=form)

@app.route("/logout", methods=["GET", "POST"])
@login_required
def logout():
    logout_user()
    return redirect(url_for("index"))

# Flask page template handlers

@app.errorhandler(404)
def not_found_error(error):
    return render_template('404.html'), 404


@app.errorhandler(500)
def internal_error(error):
    db.session.rollback()
    return render_template('500.html'), 500


@app.route('/', methods=['GET', 'POST'])
@app.route('/index', methods=['GET', 'POST'])
def index():
    return render_template('index.html',
                           title='Home',
                           minified=app.config["MINIFIED"])

# Methods for constructing the JSON response to a getAllAttributes request.

# The response is a list of objects describing the attributes that describe a
# project. These objects contain all of the information required to render the 
# form fields for a project in the front end. Each attribute corresponds to a 
# column in the database. 


# We are creating a single page application and updates are all made via ajax.
# We cannot send out forms generated by some backend forms framework because
# we can't turn them into JSON. Instead, create forms on the back end (using
# Flask WTForms), extract information from the fields/widgets on those forms,
# and send that out as JSON. We create a form for each of the five main data 
# tables.

# Each Python attribute object is a dictionary with these key/values:
#
#    attributeID    integer value used as sort order for the list of 
#                    attributes/form widgets.
#    child          to handle widgets that consist of more than one database
#                    column, we group them as parent and child. The child 
#                    attribute does NOT have its own entry in the list. The
#                    child object is the same kind of object as the parent.
#    choices        a list of option objects used to render the widgets that
#                    contain a select element. Each option object is a
#                    dictionary with keys:
#
#                        id    to be used as the option value
#                        desc  to be used as the option label
#
#    computed       True if the column is read only, otherwise False.
#    format         a format identifier used to decide which widget to use for
#                     the view or edit field for this attribute. 
#    help           help text displayed with the field edit widget.
#    label          the label for the field widget
#    multi          True if the edit field uses a multiple select widget, 
#                    otherwise False.
#    name           attribute name. Generally this is the same as the database
#                    column name.
#    required       True if this is a required attribute, False otherwise. If
#                    a select widget is required, we ensure that the choices
#                    do not include a null option.
#    table          the name of the database table containing the column for
#                    this attribute.
                   
@app.route("/getAllAttributes")
def getAllAttributesJSON():
    """ Send allAttributes data as JSON """
    return dumps(getAllAttributes())

def getAllAttributes():
    """ Return value-less attribute objects for all project atributes, grouped
        by table"""
    attributes = {}
    attributes["csrf_token"] = {"name": "csrf_token",
                                "format": "hidden"}
    attributesByTable = {}

    Description = forms.Description()
    attributesByTable["description"] = getAttributesFromForm(Description)
    attributes.update(attributesByTable["description"])
    
    Portfolio = forms.Portfolio()
    attributesByTable["portfolio"] = getAttributesFromForm(Portfolio)
    attributes.update(attributesByTable["portfolio"])
    
    Disposition = forms.Disposition()
    attributesByTable["disposition"] = getAttributesFromForm(Disposition)
    attributes.update(attributesByTable["disposition"])
    
    Project = forms.Project()
    attributesByTable["project"] = getAttributesFromForm(Project)
    attributes.update(attributesByTable["project"])
    
    Comment = forms.Comment()
    attributesByTable["comment"] = getAttributesFromForm(Comment)
    attributes.update(attributesByTable["comment"])
    
#     Upload = forms.Project()
#     attributesByTable["upload"] = getAttributesFromForm(Upload)
#     attributes.update(attributesByTable["upload"])
    
    return attributes
        
def getAttributesFromForm(form):
    """ Given a form model, gather field properties from the form widgets and 
        the data model, and return a dictionary of attribute objects."""
    tableName = getTableNameFromForm(form)

    attributes = {}
    attributes["csrf_token"] = {"name": "csrf_token",
                                "format": "hidden"}
    
    for field in form:
        if field.name in ["csrf_token", "projectID"]:
            continue
        required = getRequiredFromField(field)
        attr = {"attributeID": getattr(field.meta.model, field.name).info["attributeID"],
                "choices": getChoicesFromField(field, required),
                "computed": getReadOnlyFromField(field), 
                "format": getFormatFromField(field), 
                "help": getattr(field.meta.model, field.name).info["help"],
                "label": field.label.text,
                "multi": getMultiFromField(field),
                "name": field.name,
                "required": required,
                "table": tableName,
                }
        attributes[field.name] = attr
    
    # dateRangeSelect widget takes a year value and a quarter or month value. Make the
    # quarter/month attribute a child of the year attribute, so that they can be
    # displayed together. Take the child attribute out of the attributes dictionary.
    
    children = [attr["name"] for attr in attributes.values() if "child_for_" in attr["format"]]
    for child in children:
        parent_root = child[:child.index("In")]
        parent = [key for key in attributes.keys() if "In" in key and key[:key.index("In")] == parent_root and key != child][0]
        if parent:
            attributes[parent]["child"] = deepcopy(attributes[child])
            del attributes[child]
        
    return attributes

def getTableNameFromForm(form):
    
    if isinstance(form, forms.Description):
        return "description"
    elif isintance(form, forms.Portfolio):
        return "portfolio"
    elif isinstance(form, forms.Disposition):
        return "disposition"
    elif isinstance(form, forms.Project):
        return "project"
    elif isinstance(form, forms.Comment):
        return "comment"
    elif isinstance(form, forms.Upload):
        return "upload"
    else:
        return ""

def getFormatFromField(field):
    if field.name == "childID":
        return "multipleSelect"
    elif field.type == "QuerySelectMultipleField":
        return "multipleSelect"
    elif field.type == "IntegerField":
        return "number"
    elif "InY" in field.name or "InFY" in field.name:
        return "dateRangeSelect"
    elif "InQ" in field.name or "InM" in field.name:
        root = field.name[:field.name.index("In")]
        return "child_for_{}".format(root)
    elif field.type == "SelectField":
        return "multipleSelect"
    elif field.type == "DateField":
        return "date"
    elif field.type == "DateTimeField":
        return "date"
    elif field.type == "StringField":
        return "string"
    elif field.type == "TextAreaField":
        return "textArea"
    else:
        return "string"    

def getChoicesFromField(field, required):
    if field.name == "childID":     # odd self-referential relationship
        options = field.query_factory().order_by("projectID").all()
        return [{"id": getattr(item, "projectID"), "desc": str(getattr(item, "projectID"))} for item in options]
    elif field.type == "QuerySelectMultipleField":
        orderBy = field.name[:field.name.index("ID")] + "Desc"
        options = field.query_factory().order_by(orderBy).all()
        return getChoicesFromFactoryOptions(field, options)
    elif field.type == "SelectField" and field.name[-2:] == "ID":
        options = field.choices
        choices = getChoicesFromOptions(field, options)
        if not required:
            zeroChoice = [choice for choice in choices if str(choice["id"]) == "0"]
            if zeroChoice:
                # make sure it comes first
                zeroIndex = choices.index(zeroChoice[0])
                if not zeroIndex == 0:
                    del choices[zeroIndex]
                    choices.insert(0, {"id": 0, "desc": "none"})
        if required:
            zeroChoice = [choice for choice in choices if str(choice["id"]) == "0"]
            if zeroChoice:
                # delete it
                zeroIndex = choices.index(zeroChoice[0])
                del choices[zeroIndex]
        return choices
    elif field.type == "SelectField" and field.name[-4:] == "InFY" \
      or field.type == "SelectField" and field.name[-3:] == "InY" \
      or field.type == "SelectField" and field.name[-3:] == "InQ" \
      or field.type == "SelectField" and field.name[-3:] == "InM":
        options = field.choices
        choices = getChoicesFromOptions(field, options)
        if required:
            zeroChoice = [choice for choice in choices if str(choice["id"]) == "0"]
            if zeroChoice:
                # delete this choice if field is required
                zeroIndex = choices.index(zeroChoice[0])
                if required:
                    del choices[zeroIndex]
        return choices
    else:
        return []
            
def getChoicesFromFactoryOptions(field, options):
    root = field.name[:-2]  # take off "ID"
    return [{"id": getattr(item, root+"ID"), "desc": getattr(item, root+"Desc")} for item in options]

def getChoicesFromOptions(field, options): 
    return [{"id": item[0], "desc": item[1]} for item in options] 

def getMultiFromField(field):
    if field.type == "QuerySelectMultipleField":
        return True
    else:
        return False

def getReadOnlyFromField(field):
    return isinstance(field.widget, ReadOnlyWidgetProxy)

def getRequiredFromField(field):
    return field.flags.required

# Generate a list of brief project descriptions for all projects. This list is
# saved in the client and used for a number of purposes. Under the Select tab,
# it is used to render the Select drop down menu, and used as input to the
# Search filter.

@app.route("/getBriefDescriptions", methods=["GET", "POST"])
def getBriefDescriptions():
    """ return list of project descriptions """
    columns = ["projectID", "name", "description", "finalID"]
    descriptions = []
    for item in alch.Description.query.order_by("projectID").all():
        d = {}
        for col in columns:
            d[col] = getattr(item, col)
        descriptions.append(d)
    return dumps(descriptions)

# Under the Select tab there is an option for the user to select one of the
# controlled vocabulary attributes and get a count of projects for each value
# in that vocabulary. These two methods provide the data for rendering the
# drop down to select an attribute and to return the breakdown results, 
# respectively.

@app.route("/getBreakdownChoices")
def getBreakdownChoices():
    """ send choices for breakdown by attribute dropdown """
    table_names = db.metadata.tables.keys()
    list_names = [name[0:-4] for name in table_names if name[-4:] == "list"]
    choices = []
    
    for name in list_names:
        list_table = getattr(alch, name.capitalize()+"list")
        choice = {"id": name,
                  "desc": list_table.info["label"]}
        choices.append(choice)
    
    choices.sort(key = lambda item: item["desc"])
    return dumps(choices)  
    
@app.route("/getBreakdownByAttribute/<attributeName>")
def getBreakdownByAttribute(attributeName):
    """ send breakdown by attribute results: # projects for each value"""
    # Find out everything about the specified table columns
    allAttrsFromDB = getAllAttributes()
    col_name = attributeName+"ID"
    attr = allAttrsFromDB[col_name]
    
    # attr["choices"] represents the options, but for the filter operation
    # below we need actual SQLAlchemy objects. In alchemy_models we saved
    # the raw options table results in objects with names like TYPES_RESULTS.
    #choices = getattr(alch, attributeName.capitalize() + "list").query.all()
    choices = getattr(alch, attributeName.upper() + "_RESULTS")
    
    # tables for query
    d = alch.Description
    ld = alch.Latest_disposition
    pt = alch.Portfolio
    pr = alch.Project
    table = ""

    # start with the Description table, and join if the attribute is in another table.
    p = db.session.query(d)
    if attr["table"] == "disposition":
        table = ld
    elif attr["table"] == "portfolio":
        table = pt
    elif attr["table"] == "project":
        table = pr    
    if table:
        p = p.outerjoin(table)
    else:
        table = d

    breakdown = []
    # add a choice for selecting the null value
    if attr["multi"] or attr["table"] == "disposition":
        query_string = "{}=".format(col_name)
        query_desc = "no {}".format(attributeName)
        r = p.filter(getattr(table, col_name) == None).order_by("projectID").all()

        break_item = {"desc": query_desc,
                      "projectList": [item.projectID for item in r],
                      "query_desc": query_desc,
                      "query_string": query_string
                      }
        breakdown.append(break_item)

    for choice in choices:
        val = getattr(choice, col_name)
        desc = getattr(choice, attributeName+"Desc")
        if desc == "":
            desc = "none"
        
        # Send a string with the selection criterion description and one with
        # the selection criterion value(s).
        
        query_string = "{}={}".format(col_name, val)
        query_desc = "{}={}".format(attributeName, 
                                    "'{}'".format(desc) if " " in desc else desc)
        if attr["multi"]:
            r = p.filter(getattr(table, col_name).contains(choice))
        else:
            r = p.filter(getattr(table, col_name) == val)
        
        r = r.order_by("projectID").all()

        break_item = {"desc": desc,
                      "projectList": [item.projectID for item in r],
                      "query_desc": query_desc,
                      "query_string": query_string
                      }
        breakdown.append(break_item)
    
#     if len(breakdown):
#         if breakdown[0]["desc"] in ["", "none"]:
#             first = breakdown[0]
#             breakdown = breakdown[1:]
#             breakdown.sort(key = lambda item: item["desc"])
#             breakdown.insert(0, first)
#         else:
#             breakdown.sort(key = lambda item: item["desc"])
    
    return dumps(breakdown)

def truncate_gracefully(text_string, max_length):
    """ 
    Truncate a string at the last space character within the first max_length
    characters, if the string is longer than max_length. If so, add ellipsis.
    """
    
    added_ellipsis = ""
    if len(text_string) > max_length:
        added_ellipsis = "..."
        return text_string[0:text_string[0:max_length].rfind(" ")] + added_ellipsis
    else:
        return text_string
            
@app.route("/getReportTableJSON", methods=["POST"])
def getReportTableJSON():
    """
    Generate JSON for the DataTables data on the Report tab.
    
    POST parameters:
        projectID       a list of projectIDs of projects to be displayed
        tableColumns    a list of table columns. Only data for these columns
                        are returned (in order, not that it matters).
    """
    projectIDList = request.json.get("projectID", [])
    tableColumns = request.json.get("tableColumns", [])
    
    # Find out everything about the specified table columns
    allAttrsFromDB = getAllAttributes()
    columns = []
    for col_name in tableColumns:
        if col_name in allAttrsFromDB.keys():
            columns.append(allAttrsFromDB[col_name])
    
    # Query for all projects in specified list
    p = alch.Description.query.filter(alch.Description.projectID.in_(projectIDList)).all()
    
    response = getReportRowsFromQuery(p, columns)
    return dumps(response)

@app.route("/getReportResults", methods=["POST"])
def getReportResults():
    """ Get report data matching query_string """
        
    # Parse with strict parsing. An error will raise an exception
    query_string = request.json.get("query_string", "")
    tableColumns = request.json.get("tableColumns", [])

    # Find out everything about the specified table columns
    allAttrsFromDB = getAllAttributes()
    columns = []
    for col_name in tableColumns:
        if col_name in allAttrsFromDB.keys():
            columns.append(allAttrsFromDB[col_name])
    
    attr_names = allAttrsFromDB.keys()
    
    # Base for query
    d = alch.Description
    dp = alch.Disposition
    ld = alch.Latest_disposition
    pt = alch.Portfolio
    pr = alch.Project
    p = db.session.query(d).join(pt).join(pr).outerjoin(ld)
    
    desc = []
    query_descs = []
    filters = []
    
    if query_string != "":
        # Apply the filters specified in the query_string
        query = parse_qs(unquote(query_string), True, True)
        
        for key in query.keys():
            if key not in attr_names:
                continue
            attr = allAttrsFromDB[key]
            if attr["format"] != "multipleSelect":
                continue
            if attr["table"] == "description":
                table = d
            elif attr["table"] == "disposition":
                table = ld
            elif attr["table"] == "portfolio":
                table = pt
            elif attr["table"] == "project":
                table = pr
    
            # get unique list of integer values
            raw_values = list(set(query[key]))
            null_values = False
            if "" in raw_values:
                null_values = True
                raw_values.remove("")
                
            int_values = map(int, raw_values)
            accepted_choices = [choice for choice in attr["choices"] if choice["id"] in int_values]
            accepted_descs = ["'{}'".format(item["desc"]) if item["desc"] else "none" for item in accepted_choices]
            accepted_values = [item["id"] for item in accepted_choices]
            
            if len(accepted_descs) > 1:
                accepted_descs.sort()
                desc = "{} is {}".format(attr["label"], " or ".join(accepted_descs))
            elif len(accepted_descs) == 1:
                desc = "{}={}".format(attr["label"], accepted_descs[0])
            
            if len(accepted_values) > 1:
                filts = []
                accepted_values.sort()
                for val in accepted_values:
                    filt = "{}={}".format(key, val)
                    filts.append(filt)
                filter = "&".join(filts)
            elif len(accepted_values) == 1:
                filter = "{}={}".format(key, accepted_values[0])

            if len(accepted_values):
                query_descs.append(desc)
                filters.append(filter)
                if attr["multi"]:
                    # join with the relationship table and filter on its key column
                    table_name = "t_" + key[:-2]    # trim off "ID"
                    t = getattr(alch, table_name)
                    col = getattr(t.c, key)
                    p = p.join(t).filter(col.in_(accepted_values))
                else:
                    p = p.filter(getattr(table, key).in_(accepted_values))
            
            elif null_values:
                query_descs.append("no {}".format(attr["label"]))
                filters.append("{}=".format(key))
                p = p.filter(getattr(table, key) == None)
            
        p = p.order_by(getattr(d, "projectID"))

    response = getReportRowsFromQuery(p, columns)
    response["projectList"] = [item.projectID for item in p]
    response["query_desc"] = ", and ".join(query_descs) if len(query_descs) else "none"
    response["query_string"] = "&".join(filters)
    
    return dumps(response)
    
def getReportRowsFromQuery(p, columns):
    """ Given query result object and columns list, produce rows 
                    
    Send back 
        data            a list of rows of database query results, with just
                        projectID and the specified columns.
        columns         send back the column names and labels
        options         default datatables options
    """
    rows = []
    response = {}
    for item in p:
        row = {"projectID": getattr(item, "projectID")}
        for col in columns:
            col_name = col["name"]
            col_table = col["table"]
            if col_table == "disposition":
                if item.disposition:
                    item = item.disposition[0]
                else:
                    row[col_name] = ""
                    continue
            
            if col_table == "description" or col_table == "disposition":
                value = getattr(item, col_name)
                table_relationship = None
            else:
                # i.e., column is not in the description table, but buried 
                # in item in a backref relationship whose name matches the
                # table of interest.
                table_relationship = getattr(item, col_table)
                value = getattr(table_relationship, col_name)
            
            if col["format"] == "textArea":
                value = truncate_gracefully(value, 100)                
            elif col_name[-2:] == "ID":
                # Look in the relationship with the controlled vocabulary table
                # for a description instead what you have at this point, which
                # is just a numerical value.
                relationship_name = col_name[0:-2]
                if table_relationship and hasattr(table_relationship, relationship_name):
                    model = getattr(table_relationship, relationship_name)
                    value = getattr(model, relationship_name+"Desc")
                    if not value:
                        value = "none"
                elif hasattr(item, relationship_name):
                    model = getattr(item, relationship_name)
                    value = getattr(model, relationship_name+"Desc")
                    if not value:
                        value = "none"
                elif type(value) == type(InstrumentedList()):
                    # Multiple select fields have a relationship with a name 
                    # that has "ID" on the end, so we already have the right
                    # value, but the value is a list. Dig into the list to get
                    # the descriptions, and then join them with commas.
                    value = ", ".join([getattr(val, relationship_name+"Desc") for val in value])
            row[col_name] = value
        rows.append(row)
    
    response = {"data": rows}
    
    # Datatable column definitions for specified columns. 
    # The projectID column requires a render function, which can't be 
    # serialized. That needs to be added in the client.
    aoColumns = []
    for column in columns:
        dt_col = {"data": column["name"],
                  "title": column["label"].capitalize()}
        aoColumns.append(dt_col)
    response["columns"] = aoColumns
    
    # Datatables options
    #    Hide pagination if there is only one page of results
    #    Don't show the option to change the number of results
    #    Action is client-side, not server side
    #    No searching
    pageLength = 25
    response["options"] = {
        "destroy": True,
        "lengthChange": False,
        "pageLength": pageLength,
        "paging": len(rows) > pageLength,
        "pagingType": "full_numbers",
        "saveState": True,
        "searching": False,
        "serverSide": False
    }
    
    return response

    
# Methods for generating the JSON response to a request for all of the data for
# a given project. We generate forms on the backend, extract the data into a 
# dictionary of dictionaries and lists of dictionaries, and send them out.

# The response consists of:
#
#    projectID      projectID is the primary key for all of the major database
#                    and is the unique identifier for each project.
#    csrf_token     a cross-site request forgery token that must be returned 
#                    and validated with a request to update the database.
#    formData       a dictionary containing the projectID (again), and a
#                    data object for each of the five data tables. Each
#                    table object contains:
#
#                        tableName      the name of the database table 
#                        attributes     a list of attribute value objects
#
#                   Attribute value objects contain:
#
#                        name           attribute name
#                        printValue     an optional string used to display the
#                                        attribute value
#                        value          the attribute value, which may be:
#                                         a single string or number,
#                                         a dictionary with keys "id" and "desc", or
#                                         a list of {id, desc} objects.

# The idea is that the client will merge the project data generated here with 
# the list of attributes sent out once at the beginning of the session. 

@app.route("/getProjectAttributes/<projectID>")
def getProjectAttributesJSON(projectID):
    """ send attribute values for project as JSON """
    attributes = getProjectAttributes(projectID)
    
    return dumps(attributes)

def getProjectAttributes(projectID, tableName=None):
    """ Render a WT Forms form from the request/db, pick out the data from the
        widgets, and send them out as JSON.
    """
    # If a tableName is supplied, only send attributes in that table
    
    allAttrsFromDB = getAllAttributes()
        
    formData = []
    
    p = alch.Description.query.filter_by(projectID=projectID).first()
    if not p:
        # send back forms with no data (for creating a new project)
        p = alch.Description()
        p.portfolio = [alch.Portfolio()]
        p.project = [alch.Project()]
        p.comments = []
        p.dispositions = []
    descriptionForm = forms.Description(request.form, p)
    csrf_token = descriptionForm["csrf_token"].current_token

    if tableName in ("description", None):
         formData.append(getAttributeValuesFromForm(descriptionForm, allAttrsFromDB))
    
    if tableName in ("portfolio", None):
        portfolioForm = forms.Portfolio(request.form, p.portfolio[0])
        formData.append(getAttributeValuesFromForm(portfolioForm, allAttrsFromDB))
    
    if tableName in ("project", None):
        projectForm = forms.Project(request.form, p.project[0])
        formData.append(getAttributeValuesFromForm(projectForm, allAttrsFromDB))
    
    if tableName in ("disposition", None):
        if len(p.dispositions):
            d = alch.Disposition.query.filter_by(projectID=projectID)\
                                      .order_by(db.desc("disposedInFY"))\
                                      .order_by(db.desc("disposedInQ"))
            # Using request.form here would step on data from db
            dispositions = [forms.Disposition(ImmutableMultiDict([]), disposition) for disposition in d]
            formData.append({"tableName": "disposition",
                             "attributes": [{"tableName": "disposition", 
                                             "attributes": getAttributeValuesFromForm(item, allAttrsFromDB)["attributes"]} for item in dispositions]})
        else:
            formData.append({"tableName": "disposition",
                             "attributes": [{"tableName": "disposition", 
                                             "attributes": []}]})
            
    if tableName in ("comment", None):
        if len(p.comments):
            c = alch.Comment.query.filter_by(projectID=projectID)\
                                  .order_by(db.desc("commentAuthored"))
            comments = [forms.Comment(ImmutableMultiDict([]), comment) for comment in c]
            formData.append({"tableName": "comment",
                             "attributes": [{"tableName": "comment", 
                                             "attributes": getAttributeValuesFromForm(item, allAttrsFromDB)["attributes"]} for item in comments]})
        else:
            formData.append({"tableName": "comment",
                             "attributes": [{"tableName": "comment", 
                                             "attributes": []}]})
            
#    if tableName in ("description", None):
#     uploadForm = forms.Upload(request.form, p.uploads[0])

    
    return {"projectID": projectID,
            "csrf_token": csrf_token,
            "formData": formData}
        
def getAttributeValuesFromForm(form, allAttrsFromDB):
    """ Take a rendered form, inspect the widgets, and pull out their values
        and choices (vocabularies).  Different widgets have values in different 
        places. Make parent/child combinations. Compute printValues that will
        just be printed in view mode.
    """
    token = ""
    attributes = []

    tableName = getTableNameFromForm(form)
    for field in form:
        if field.name in ["projectID","csrf_token"]:
            continue
        
        name = field.name
        value = field.data
        printValue = ""
        if "In" in field.name:
            # One of the in year fields, hence parent, or quarter or month,
            # and so a child. Only parents are in the allAttrs list.
            if allAttrsFromDB.has_key(field.name):
                dbattr = allAttrsFromDB[field.name]
            else:
                # must be somebody's child
                child = field.name
                parent_root = child[:child.index("In")]
                parent = [key for key in allAttrsFromDB.keys() if "In" in key and key[:key.index("In")] == parent_root and key != child][0]
                dbattr = allAttrsFromDB[parent]["child"]
        else:
            dbattr = allAttrsFromDB[field.name]

        if name == "childID":
            value = [item for item in dbattr["choices"] if item["id"] in [d.projectID for d in field.data]]

        elif dbattr["format"] == "multipleSelect" and dbattr["multi"] == True:
            root = field.name[:-2]
            choices = dbattr["choices"]
            value = [item for item in choices if item["id"] in [getattr(data, root+"ID") for data in field.data]]
            printValue = ", ".join([item["desc"] for item in value])
        
        elif dbattr["format"] == "multipleSelect" and dbattr["multi"] == False:
            data = field.data
            if data == None:
                pass
            value = [item for item in dbattr["choices"] if item["id"] == data]
            value = value[0] if value else None
            
        elif dbattr["format"] == "dateRangeSelect":
            value = [item for item in dbattr["choices"] if item["id"] == field.data]
            value = value[0] if value else None
            if dbattr["child"]:
                dbChild = dbattr["child"]
                childName = dbChild["name"]
                formChild = form[childName]
                childValue = [item for item in dbChild["choices"] if item["id"] == formChild.data]
                childValue = childValue[0] if childValue else None
                attributes.append({"name": childName,
                                   "value": childValue,
                                   "printValue": childValue["desc"] if childValue else ""})
        
        elif dbattr["format"] == "textArea":
            # turn a blank text line into "<br><br>" HTML blank line for output.
            # PostgreSQL seems to spit out "\n" and MySQL sends out "\r\n" for line feed
            data = field.data
            printValue = "<br><br>".join(data.split("\n\n")) if data else ""
        
        elif "child_for_" in dbattr["format"]:
            continue

        elif isinstance(field, DateField):
            data = field.data
            value = data.isoformat() if data else ""
            printValue = data.strftime("%m/%d/%Y") if data else ""
           
        elif isinstance(field, DateTimeField):
            data = field.data
            value = data.isoformat() if data else ""
            printValue = data.strftime("%m/%d/%Y %I:%M:%S %p") if data else ""
           
        attributes.append({"name": name,
                           "value": value,
                           "printValue": printValue})

    return {"tableName": tableName, "attributes": attributes}
    
def getTableNameFromForm(form):
    """ compare form with prototype instances to find the match """
    if isinstance(form, forms.Description):
        tableName = "description"
    
    elif isinstance(form, forms.Portfolio):
        tableName = "portfolio"
    
    elif isinstance(form, forms.Project):
        tableName = "project"
    
    elif isinstance(form, forms.Disposition):
        tableName = "disposition"
    
    elif isinstance(form, forms.Comment):
        tableName = "comment"
    
    return tableName
    
# Update database from request. The request will have data for only a single 
# table, and only updated data from that table is returned. 
#
# Check the jwt, csrf token, and the user's roles before doing anything.

@app.route("/projectEdit/<projectID>/<tableName>", methods=["GET", "POST"])
@cross_origin(headers=['Content-Type', 'Authorization'])
@jwt_required()
def projectEdit(projectID, tableName):
    """ update specified table for specified project"""
    if 'Curator' not in current_user.groups:
        # Must be a Curator to edit project metadata
        abort(401)

    if projectID:
        p = alch.Description.query.filter_by(projectID=projectID).first_or_404()
        p.lastModified = datetime.now()

        errors = []
        success = []
        
        if tableName == "description":
            description_errors = []
            description_success = "Project description was updated."
            old_maturityID = p.maturityID
            old_finalID = p.finalID

            descriptionForm = forms.Description(request.form, p)
            if descriptionForm.validate_on_submit():
                try:
                    descriptionForm.populate_obj(p)
                    db.session.add(p)
                    db.session.commit()
                except:
                    description_errors.append(sys.exc_info()[0])
            else:
                description_errors = descriptionForm.errors
        
            response = getProjectAttributes(projectID, tableName)
            if description_errors:
                response["errors"] = description_errors
            else:
                if not descriptionForm.maturityID == old_maturityID:
                    pass
                response["success"] = description_success            

        elif tableName == "portfolio":
            pt_errors = []
            pt_success = "Project portfolio entry was updated."
            pt = alch.Portfolio.query.filter_by(projectID=projectID).first_or_404()
            portfolioForm = forms.Portfolio(request.form, pt)
            if portfolioForm.validate_on_submit():
                try:
                    portfolioForm.populate_obj(pt)
                    db.session.add(pt)
                    db.session.commit()
                    projectID = pt.projectID
                except:
                    pt_errors.append(sys.exc_info()[0])
            else:
                pt_errors = portfolioForm.errors

            response = getProjectAttributes(projectID, tableName)
            if pt_errors:
                response["errors"] = pt_errors
            else:
                response["success"] = pt_success

        elif tableName == "project":
            pr_errors = []
            pr_success = "Project management entry was updated."
            # old_progressID = p.progressID
            
            pr = alch.Project.query.filter_by(projectID=projectID).first_or_404()
            projectForm = forms.Project(request.form, pr)
            if projectForm.validate_on_submit():
                try:
                    projectForm.populate_obj(pr)
                    db.session.add(pr)
                    db.session.commit()
                    projectID = pr.projectID
                except:
                    pr_errors.append(sys.exc_info()[0])
            else:
                pr_errors = projectForm.errors

            response = getProjectAttributes(projectID, tableName)
            if pr_errors:
                response["errors"] = pr_errors
            else:
                response["success"] = pr_success

        elif tableName == "disposition":
            d_errors = []
            disposedInFY = request.form.get("disposedInFY")
            disposedInQ = request.form.get("disposedInQ")
            d = alch.Disposition.query.filter_by(projectID=projectID)\
                                      .filter_by(disposedInFY=disposedInFY)\
                                      .filter_by(disposedInQ=disposedInQ).first()
            if not d:
                # No matching primary key. Generate model from request and insert.
                d = alch.Disposition(disposedInFY = disposedInFY,
                                     disposedInQ = disposedInQ,
                                     dispositionID = request.form.get("dispositionID"),
                                     explanation = request.form.get("explanation"),
                                     finishInM = request.form.get("finishInM"),
                                     finishInY = request.form.get("finishInY"),
                                     projectID = projectID,
                                     reconsiderInFY = request.form.get("reconsiderInFY"),
                                     reconsiderInQ= request.form.get("reconsiderInQ"),
                                     startInM = request.form.get("startInM"),
                                     startInY = request.form.get("requestInY"),
                                     lastModifiedBy = current_user.get_id())
                d_success = "A new project disposition was created for cycle "
            else:
                d_success = "Updated project disposition for cycle "
            
            dispositionForm = forms.Disposition(request.form, d)
            if dispositionForm.validate_on_submit():
                try:
                    dispositionForm.populate_obj(d)
                    db.session.add(d)
                    db.session.commit()
                except:
                    d_errors.append(sys.exc_info()[0])
            else:
                d_errors.append(dispositionForm.errors)

            response = getProjectAttributes(projectID, tableName)
            if d_errors:
                response["errors"] = d_errors
            else:
                disposedInFY = dispositionForm["disposedInFY"].data
                FY = [item[1] for item in dispositionForm["disposedInFY"].choices if item[0] == disposedInFY][0]
                disposedInQ = dispositionForm["disposedInQ"].data
                Q = [item[1] for item in dispositionForm["disposedInQ"].choices if item[0] == disposedInQ][0]
                cycle = "{FY} {Q}.".format( FY = FY,
                                           Q = Q)
                response["success"] = d_success + cycle

        elif tableName == "comment":
            c_errors = []
            commentID = int(request.form.get("commentID"))
            
            if commentID:
                c = alch.Comment.query.filter_by(projectID = projectID)\
                                      .filter_by(commentID = commentID).first_or_404()
                commentForm = forms.Comment(request.form, c)
                c_success = "The comment was updated."

            else:
                c = alch.Comment(projectID=projectID)
                mock_form = ImmutableMultiDict([("csrf_token", request.form.get("csrf_token")),
                                                ("comment", request.form.get("comment")),
                                                ("commentAuthor", current_user.get_id()),
                                                ("commentAuthored", datetime.now().strftime("%Y-%m-%d %H:%M:%S")),
                                                ("commentEditor", None),
                                                ("commentEdited", None)])
                commentForm = forms.Comment(mock_form, c)
                c_success = "A new comment was created."
            
            if commentForm.validate_on_submit():
                try:
                    commentForm.populate_obj(c)
                    db.session.add(c)
                    db.session.commit()
                except:
                    c_errors.append(sys.exc_info()[0])
            else:
                c_errors.append(commentForm.errors)
        
            response = getProjectAttributes(projectID, tableName)
            if c_errors:
                response["errors"] = c_errors
            else:
                response["success"] = c_success

        return dumps(response)

# Check the jwt, csrf token, and the user's roles before doing anything.
#
# The data returned are the same as those from getProjectAttributes plus:
#
#    errors    error messages if an error occurred, else nothing
#    success   specific success message if no error occurred, else nothing
 
@app.route("/projectCreate", methods=["POST"])   
@cross_origin(headers=['Content-Type', 'Authorization'])
@jwt_required()
def projectCreate():
    """ create new project """

    if 'Curator' not in current_user.groups:
        # Must be a Curator to edit project metadata
        abort(401)
    
    description_errors = []
    
    p = alch.Description(created = datetime.today().strftime("%Y-%m-%d"),
                         lastModifiedBy = current_user.get_id())

    descriptionForm = forms.Description(request.form, p)
    if descriptionForm.validate_on_submit():
        try:
            descriptionForm.populate_obj(p)
            db.session.add(p)
            db.session.commit()
            projectID = p.projectID
        except:
            description_errors.append(sys.exc_info()[0])
    else:
        description_errors = descriptionForm.errors
    
    if description_errors:
        response = getProjectAttributes(p.projectID or 0, "description")
        response["errors"] = description_errors
        return dumps(response)

    pt = alch.Portfolio(projectID = p.projectID,
                        lastModifiedBy = current_user.get_id())
    portfolioForm = forms.Portfolio(request.form, pt)

    pr = alch.Project(projectID = p.projectID,
                      lastModifiedBy = current_user.get_id())
    projectForm = forms.Project(projectID = p.projectID)

    if portfolioForm.validate_on_submit() and projectForm.validate_on_submit():
        try:
            portfolioForm.populate_obj(pt)
            db.session.add(pt)
            projectForm.populate_obj(pr)
            db.session.add(pr)
            db.session.commit()
        except:
            description_errors.append(sys.exc_info()[0])
    else:
        description_errors = portfolioForm.errors + projectForm.errors

    response = getProjectAttributes(projectID, "description")
    if description_errors:
        response["errors"] = description_errors
    else:
        response["success"] = "Created new project"            
        response["projectID"] = projectID

    return dumps(response)
         
    
    